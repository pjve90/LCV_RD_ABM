---
title: 'Life cycle variation and resource dynamics ABM: Code'
author: "Pablo J. Varas Enr√≠quez"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setlocale("LC_TIME", "C")
```

## Outline

The following code is meant to develop an agent-based model to understand how the resource dynamics of female individuals influence the variability of life cycles at the population level. For this, the following variables are needed in the model, at the individual and population levels:

| Level | Life cycle | Resource dynamic |
| --- | --- | --- |
| Individual | Longevity |  Lifetime production variability |
|  | Lifetime reproductive output | Lifetime resource production |
|  | Age at # reproduction | Lifetime consumption variability |
|  | Average interbirth interval |  Lifetime resource consumption |
|  | Age at life cycle stage transition |  Lifetime storage variability |
|  |  | Lifetime resource storage |
|  |  | Lifetime giving variability |
|  |  | Lifetime resource given |
|  |  | Lifetime recieving variability |
|  |  | Lifetime resource recieved |
| Population | Longevity variability | |
|  | Lifetime reproductive output variability | |
|  | Age at # reproduction variability | |
|  | Average interbirth interval variability | |
|  | Age at life cycle stage transition variability | |

At first, there is a section called "Starting point", which are the first attempts and checks of the model. Different modules are used to build the initial states of the model, with less life cycle stages and resource dynamics. Once less modules work, more modules will be developed and included in the model. The starting point has one life cycle, and two resource dynamics (i.e. production, consumption), and builds-up from there.

The following sections are the different scenarios where the model will be used. The scenarios are:

- A population where all individuals have medium probabilities of resource production and sharing.
- A population where all individuals have high probabilities for resource production and sharing.
- A population where most individuals (75% of the population) have a high probability of production and low probability of sharing. The rest (25%) have medium probabilities for production and sharing.
- A population where most individuals (75% of the population) have a low probability of production and high probability of sharing. The rest (25%) have medium probabilities for production and sharing.
- A population where all individuals have low probabilities for resource production and sharing.

### Starting point

The starting point section consists of the different attempts to start building the model. First, there will be one life cycle stage and the resource dynamics of production and consumption. Second, one with two life cycle stages, production, and consumption. Third, storage will be added, and finally, one with sharing dynamics.

#### First attempt: one life cycle stage, two resource dynamics.

An agent-based model is developed here with a population of 1000 indvidiuals that have only one life cycle stage and experience two resource dynamics (i.e. production and consumption).

First, a database is set to record the variability of life cycles at the population level. The following variables are used to characterize the life cycle variability:

- `lng_var`: Longevity variance
- `lro_var`: Lifetime reproductive output variance
- `age_repro_i_var`: Age at the $i$th reproduction variance. A new variable is made for the age of each reproductiv event.
- `ibi_var`: Average interbirth interval variance.

Second, a database is set to record the final outcome of life cycles and resource dynamics of each of the 1000 individual in the population. This database is used to calculate the variability of life cycles at the population level. The variables used are:

- `ID`: identity of the individual.
- `age`: number of years the individuals lives.
- `prod_n`: total number of successful outcomes in resource production by the individual in her life cycle.
- `prod`: total amount of resources produced by the individual in her life cycle.
- `cons`: total amount of resources consumed by the individual in her life cycle.
- `lro`: lifetime reproductive output.
- `age_repro:i`: age at which the individual has her $i$th descendant. There should be a new one for each reproductive event.
- `ibi`: average interbirth interval.

Third, a database is set to record the individual dynamics in the population in one iteration (i.e. one year). This database is used to record the development of the different individuals across their life cycle, by recording the changes from one year to another, and estimate the final outcomes of each individual. The variables used are:

- `ID`: identity of the individual.
- `surv`: outcome from the survival function. The individual can survive (1) or not (0).
- `age`: number of years the individual has.
- `prod_o`: outcome from the resource production function. The individual can produce (1) or not (0).
- `prod_a`: amount of resources produced by the individual in the iteration. At initialisation the amount of resources is the maximum (1) to resemble the amount of resources the individual gets during gestation.
- `cons`: amount of resources consumed by the individual in the iteration.
- `repro`: outcome from the reproduction function. The individual can reproduce (1) or not (0).

```{r}
#life cycle variability database
lcv_pop <- data.frame(lng_var=NA,lro_var=NA,age_repro_i_var=NA,ibi_var=NA)
#check data frame
head(lcv_pop)

#individual final outcome database
final_indpop <- data.frame(id=1:1000,age=rep(NA,length.out=1000),prod_n=rep(NA,length.out=1000),prod=rep(NA,length.out=1000),cons=rep(NA,length.out=1000),lro=rep(NA,length.out=1000),age_repro_i=rep(NA,length.out=1000),ibi=rep(NA,length.out=1000))
#check data frame
head(final_indpop)

#individual iteration database
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
```

The auxiliary variables are defined for the model. Auxiliary variables are fixed values set at initialisation that define the life-history and resource dynamics that individuals can experience. Regarding life-history dynamics, you define the surviving probability (`surv_p`) and cost (`surv_c`), the reproductive probability (`repro_p`), cost (`repro_c`), and number of descendants per reproduction (`repro_n`). Resource-related auxiliary variables are the probability of production (`prod_p`), the amount that can be produced (`prod_n`), and the amount of resources that are consumed (`cons_n`).

```{r}
####values are made up for now

#survival
#probability of surviving
surv_p <- 0.75
#cost of surviving
surv_c <- 0.25

#reproduction
#probability
repro_p <- 0.5
#cost of reproduction
repro_c <- 0.25
#number of descendants per reproduction
repro_n <- 1

#production
#probability
prod_p <- 0.5
#amount of resources produced
prod_n <- 1

#consumption
#amount of resources consumed
cons <- 0.25
```

The functions for state variables are defined backwards from how the databases were defined, starting from the functions for each individual and ending with the functions for the calculations at the population level. First, the functions for survival, die and age are defined, followed by the discount on the amount of resources due to the costs of survival. An individual can either survive (1) or not (0) in the survival function, based on a binomial distribution. The probability of the binomial distribution is based on the survival probability in the auxiliary variables (`surv_p`) and *weighted by the amount of resources produced (`it_indpop$prod_a`)*. Individuals that do not survive, are removed after the survival outcome is known, before ageing.

```{r}
#survival
survive <- function(it_indpop){
  if(it_indpop$prod_a[i] >= surv_c){
  it_indpop$surv[i] <- rbinom(1,1,surv_p)#*it_indpop$prod_a[i])
  }
  else{
  it_indpop$surv[i] <- 0
  }
  return(it_indpop$surv)
}

#I think a solution for the "weighting" problem is to make the survival depend on having the resources or not, so if you don't have the resources you definitely die, and if you have them you go through the random option of surviving or not.

#age
age <- function(it_indpop){
  it_indpop$age[i] <- it_indpop$age[i]+it_indpop$surv[i]
  return(it_indpop$age)
}

#survival costs
survive_c <- function(it_indpop) {
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-surv_c
    return(it_indpop$prod_a)
  }
```

The functions for resource production and consumption are defined here. First is the probability of producing resources, then the amount of new resources, followed by the discount due to consumption. The production function tells if an individual produces new resources (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the production probability in the auxiliary variables.

```{r}
#production
produce <- function(it_indpop){
  it_indpop$prod_o[i] <- rbinom(1,1,prod_p)
  return(it_indpop$prod_o)
}

#adding resources produced
produce_a <- function(it_indpop) {
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n
  return(it_indpop$prod_a)
}

#consumption
consume <- function(it_indpop) {
  it_indpop$cons[i] <- cons
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons
  return(it_indpop)
}

#Dieter:
# For both though, i wonder whether you need to plan the functions more flexibly. If I understand it correctly, the production probability can change according to the stage the individual is in. So I think that this should be part of the function definition:

# produce <- function(ind,production_probability){
#  ind$prod<-rbinom(nrow(ind),1,production_probability)
#  return(ind)
# }

# The function can than be used as:
# produce(pop,prod_p)
# Where the prod_p can be adjusted according to the stage of the individuals. Though I assume if you end up having a population where individuals are in different stages, you presumably want to make this a two-step process:

# produce <- function(ind){
#  ind$proc_b<-ifelse(ind$age<6,proc_b_infant,ifelse(ind$age<15,proc_b_juvenile,0))  # I think there is some way to set this up better
#  ind$prod<-rbinom(nrow(ind),1,ind$proc_b)
#  return(ind)
# }

#Pablo:
#I think the last option sounds like the best. However, I thought the stage-specific probabilities were set as auxiliary variables, which is why I was not considering them in the function definitions. Is this a good way to do it? Do you think is necessary to solve it for this model, where individuals don't transition to another life cycle stage, or can it be dealt in the next one where individuals have two stages?

```

The functions for the reproductive dynamics are defined here. First the probability of reproducing is defined, followed by the reproductive costs, and adding the newborn in the population. The reproduction function tells if an individual reproduces (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the reproduction probability in the auxiliary variables (`repro_p`) and *weighted by the amount of resources produced (`it_indpop$prod_a`)*. 


```{r}
#reproduction probability
reproduce <- function(it_indpop){
  if(it_indpop$prod_a[i] >= repro_c) {
  it_indpop$repro[i] <- rbinom(1,1,repro_p)#*it_indpop$prod_a)
  }else{
  it_indpop$repro[i] <- 0
  }
  return(it_indpop$repro)
}

#reproductive costs
reproduce_c <- function(it_indpop) {
  if(it_indpop$repro[i] == 1){
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-repro_c
  }else{
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]
  }
    return(it_indpop$prod_a)
}

#adding the newborn
#new_ind <- function(it_indpop){
#  it_indpop <- rbind(it_indpop,data.frame(id=(max(it_indpop$id)+1):((max(it_indpop$id)+1)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"]))))
#  return(it_indpop)
#}

#this one did not work out well so I put it directly on the code for one iteration.
```

Now the functions are used in the 1000 individuals in the population for one iteration.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))

#I tried like a set up function instead of writing the whole data frame, but it messed up the id because it was giving everybody an id of 1000 instead of a number between 1 and 1000.

#run one iteration for all the population
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#check the population by the end of the iteration
head(it_indpop)
```

Let's see how to it looks like if you run 100 iterations.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))

#run 100 iterations
for (b in 1:100){
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
}

#check the population by the end of the iterations
head(it_indpop)
```


The functions to feed the second database are defined now that one iteration works. Remember, the second database is meant to record the whole life cycle of each individual in the populations and the resource dynamics she experienced as well. Therefore, the functions should address the id of an individual (`id`), her age (`age`), the amount of succesful outcomes in resource production (`prod_n`), the total amount of resources produced (`prod`), consumed (`cons`), her lifetime reproductive output (`lro`), the age at which she had her $i$th descendant (`age_rero_i`), and her average interbirth interval (`ibi`).

```{r}
#id
id_final <- function(final_indpop){
  final_indpop$id[i] <- it_indpop$id[i]
  return(final_indpop$id)
}

#age
age_final <- function(final_indpop){
  final_indpop$age[i] <- it_indpop$age[i]
  return(final_indpop$age)
}

#total amount of successulf outcomes in production
produce_final_o <- function(final_indpop){
  final_indpop$prod_n[i] <- final_indpop$prod_n[i]+it_indpop$prod_o[i]
  return(final_indpop$prod_n)
}

#total amount of resources produced
produce_final_a <- function(final_indpop){
  final_indpop$prod[i] <- final_indpop$prod[i]+it_indpop$prod_a[i]
  return(final_indpop$prod)
}

#lifetime reproductive output
lro <- function(final_indpop){
  final_indpop$lro[i] <- final_indpop$lro[i]+it_indpop$repro[i]
  return(final_indpop$lro)
}

#age at ith reproduction
#age_repro_i <- function(final_indpop){
 # if(it_indpop$repro[i]==1){
  #final_indpop$age_repro_i[i] <- it_indpop$age[i]

  #}
#}

#Not sure how to make a new column with the age at subsequent reproductive events.

#average interbirth interval
#avg_ibi <- function(final_indpop){
  #final_indpop$ibi[i] <- (final_indpop$age_repro_i[i]-final_indpop$age_repro_i[i])/final_indpop$lro
  #return(final_indpop$ibi)
#}

#It should work depending on how the final_indpop$age_repro_i[i] can refer to the age at last and first reproduction.

````

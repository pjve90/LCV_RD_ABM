---
title: 'Life cycle variation and resource dynamics ABM: Code'
author: "Pablo J. Varas Enr√≠quez"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setlocale("LC_TIME", "C")
#install.packages("tidyverse")
library(tidyverse)
```

## Outline

The following code is meant to develop an agent-based model to understand how the resource dynamics of female individuals influence the variability of life cycles at the population level. For this, the following variables are needed in the model, at the individual and population levels:

| Level | Life cycle | Resource dynamic |
| --- | --- | --- |
| Individual | Longevity |  Lifetime production events |
|  | Lifetime reproductive output | Lifetime resource production |
|  | Age at # reproduction | Lifetime consumption events |
|  | Average interbirth interval |  Lifetime resource consumption |
|  | Age at life cycle stage transition |  Lifetime storage events |
|  |  | Lifetime resource storage |
|  |  | Lifetime giving events |
|  |  | Lifetime resource given |
|  |  | Lifetime recieving events |
|  |  | Lifetime resource recieved |
| Population | Longevity variability | Production events variability |
|  | Lifetime reproductive output variability | Resources produced variability |
|  | Age at # reproduction variability | Consumption events variability |
|  | Average interbirth interval variability | Resources consumed variability |
|  | Age at life cycle stage transition variability | Storage events variability |
|  |  | Resources stored variability |
|  |  | Giving events variability |
|  |  | Resources given variability |
|  |  | Recirving events variability |
|  |  | Resources recieved variability |

At first, there is a section called "Starting point", which are the first attempts and checks of the model. Different modules are used to build the initial states of the model, with less life cycle stages and resource dynamics. Once less modules work, more modules will be developed and included in the model. The starting point has one life cycle, and two resource dynamics (i.e. production, consumption), and builds-up from there.

The following sections are the different scenarios where the model will be used. The scenarios are:

- A population where all individuals have medium probabilities of resource production and sharing.
- A population where all individuals have high probabilities for resource production and sharing.
- A population where most individuals (75% of the population) have a high probability of production and low probability of sharing. The rest (25%) have medium probabilities for production and sharing.
- A population where most individuals (75% of the population) have a low probability of production and high probability of sharing. The rest (25%) have medium probabilities for production and sharing.
- A population where all individuals have low probabilities for resource production and sharing.

### Starting point

The starting point section consists of the different attempts to start building the model. First, there will be one life cycle stage and the resource dynamics of production and consumption. Second, one with two life cycle stages, production, and consumption. Third, storage will be added, and finally, one with sharing dynamics.

#### First attempt: one life cycle stage, two resource dynamics.

An agent-based model is developed here with a population of 1000 indvidiuals that have only one life cycle stage and experience two resource dynamics (i.e. production and consumption).

First, a database is set to record the variability of life cycles at the population level. The following variables are used to characterize the life cycle variability:

- `lng_var`: Longevity variance
- `lro_var`: Lifetime reproductive output variance
- `age_repro_i_var`: Age at the $i$th reproduction variance. A new variable is made for the age of each reproductiv event.
- `ibi_var`: Average interbirth interval variance.

Second, a database is set to record the final outcome of life cycles and resource dynamics of each of the 1000 individual in the population. This database is used to calculate the variability of life cycles at the population level. The variables used are:

- `ID`: identity of the individual.
- `age`: number of years the individuals lives.
- `prod_n`: total number of successful outcomes in resource production by the individual in her life cycle.
- `prod`: total amount of resources produced by the individual in her life cycle.
- `cons`: total amount of resources consumed by the individual in her life cycle.
- `lro`: lifetime reproductive output.
- `age_repro:i`: age at which the individual has her $i$th descendant. There should be a new one for each reproductive event.
- `ibi`: average interbirth interval.

Third, a database is set to record the individual dynamics in the population in one iteration (i.e. one year). This database is used to record the development of the different individuals across their life cycle, by recording the changes from one year to another, and estimate the final outcomes of each individual. The variables used are:

- `ID`: identity of the individual.
- `surv`: outcome from the survival function. The individual can survive (1) or not (0).
- `age`: number of years the individual has.
- `prod_o`: outcome from the resource production function. The individual can produce (1) or not (0).
- `prod_a`: amount of resources produced by the individual in the iteration. At initialisation the amount of resources is the maximum (1) to resemble the amount of resources the individual gets during gestation.
- `cons`: amount of resources consumed by the individual in the iteration.
- `repro`: outcome from the reproduction function. The individual can reproduce (1) or not (0).

```{r}
#life cycle variability database
lcv_pop <- data.frame(lng_var=NA,lro_var=NA,age_repro_i_var=NA,ibi_var=NA)
#check data frame
head(lcv_pop)

#individual final outcome database
final_indpop <- data.frame(id=1:1000,age=rep(NA,length.out=1000),prod_n=rep(NA,length.out=1000),prod=rep(NA,length.out=1000),cons=rep(NA,length.out=1000),lro=rep(NA,length.out=1000),afr=rep(NA,length.out=1000),alr=rep(NA,length.out=1000),av_ibi=rep(NA,length.out=1000))
#check data frame
head(final_indpop)

#individual multiple iterations
it_indpop_mult <- data.frame(id=1:1000,surv_1=rep(NA,length.out=1000),prod_1=rep(0,length.out=1000),cons_1=rep(NA,length.out=1000),repro_1=rep(0,length.out=1000))

#individual one iteration database
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
```

The auxiliary variables are defined for the model. Auxiliary variables are fixed values set at initialisation that define the life-history and resource dynamics that individuals can experience. Regarding life-history dynamics, you define the surviving probability (`surv_p`) and cost (`surv_c`), the reproductive probability (`repro_p`), cost (`repro_c`), and number of descendants per reproduction (`repro_n`). Resource-related auxiliary variables are the probability of production (`prod_p`), the amount that can be produced (`prod_n`), and the amount of resources that are consumed (`cons_n`).

```{r}
####values are made up for now

#survival
#probability of surviving
surv_p <- 0.75
#cost of surviving
surv_c <- 0.25
#age-specific cost of surviving
surv_c_age <- c(surv_c,surv_c*exp(exp(surv_c)/20*c(1:100))) 

#reproduction
#probability
repro_p <- 0.5
#cost of reproduction
repro_c <- 0.25
#age-specific cost of reproduction
repro_c_age <- c(repro_c,repro_c*exp(exp(repro_c)/20*c(1:100)))
#number of descendants per reproduction
repro_n <- 1

#production
#probability
prod_p <- 0.5
#amount of resources produced
prod_n <- 1

#consumption
#amount of resources consumed
cons <- 0.25
```

The functions for state variables are defined backwards from how the databases were defined, starting from the functions for each individual and ending with the functions for the calculations at the population level. First, the functions for survival probability, and age are defined, followed by the discount on the amount of resources due to the costs of survival. An individual can either survive (1) or not (0) in the survival function, based on a binomial distribution. The probability of the binomial distribution is based on the survival probability in the auxiliary variables (`surv_p`) and *weighted by the amount of resources produced (`it_indpop$prod_a`)*. Individuals that do not survive, are removed after the survival outcome is known, before ageing.

```{r}
#survival
survive <- function(it_indpop){
  if(it_indpop$prod_a[i] >= surv_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(surv_p+log(it_indpop$prod_a[i]+1)/20)){
  it_indpop$surv[i] <- 1
  }
  else{
  it_indpop$surv[i] <- 0
  }
  return(it_indpop$surv)
}

#Pablo:
#I think a solution for the "weighting" problem is to make the survival depend on having the resources or not, so if you don't have the resources you definitely die, and if you have them you go through the random option of surviving or not.
# From Dieter: I think this goes back to the discussion in the TICEL meeting, about the function that links inputs to outputs. To me, for survival, there are two steps: first, assign an individual specific level of survival depending on the resources. So there is a function that links resources to a probability. Maybe the easiest is something similar to what you have: when resources are below a critical threshold, individuals will definitely die; if resources reach that threshold, there is a baseline survival probability; if individuals have more resources, their survival probability increases. That increase probably follows a logarithmic function, with additional resources leading to smaller increases. The second step is that we draw a random number for this individual between 0 and 1 (runif(1,min=0,max=1)) and see whether that number is smaller than the probability to survive. Here is such a suggestion. I am dividing the log benefit by 20 to bring it onto the relevant scale - so if the baseline survival is 0.75, and individual with 100 resources will now have a survival of 0.75 + log(100)/20 = 0.75 + 0.23 = 0.98. With this example, most individuals survive, so if you use this variant without changing anything else, the population will explode.
#Pablo: I changed the survival function to what you suggest and I think it clearly nails the discussion in the TICEL meeting. I have two questions: 1) why is it necessary to divide by 20 to bring it onto the relevant scale? and 

# From Dieter:
# It might be useful to plot the functions to get an idea of how it influences the baseline probability. For example, should the baseline be the average or should it be the starting point? Should there be a steep incline or just a small change? Should the change be abrupt or gradual across the whole range? It also matters how you measure resources (are they measured in units of 1 or smaller units, what could the maximum be etc.) Here are four options that illustrate these differences based on what you set above that the production of resources is ~0.5 - so small steps and going up to a maximum of 10 resources (40 steps of production with baseline production (0.5) + consumption (0.25) - 40*0.25=10). I think you will probably decide the shape depending on the references you wanted to use? 

#Pablo:
#If I understand correctly, dividing by 20 is to make the survival probability have values below one, right? I updated the code below then so the baseline production is 1 (0.5 is the probability of producing one resource), the resources vector would have a maximum of 75 resources (100 steps of production with baseline production (1) + consumption (0.25), 100*0.75=75), and I divide by 20, 20_neg, 10, and the dive6.

# 
resources<-seq(from=0,to=75,length.out=101)
survival_probabilities_20<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20[i]<-0}else{survival_probabilities_20[i]<-surv_p+log(resources[i]+1)/20}
}

survival_probabilities_20_neg<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20_neg[i]<-0}else{survival_probabilities_20_neg[i]<-surv_p+log(resources[i])/20}
}

survival_probabilities_10<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_10[i]<-0}else{survival_probabilities_10[i]<-surv_p+log(resources[i]+1)/10}
}

survival_probabilities_div6<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_div6[i]<-0}else{survival_probabilities_div6[i]<-surv_p+(log(resources[i]/2)/6) }
}

plot(survival_probabilities_20~resources,xlim=c(0,75),ylim=c(0,1.3))
abline(h=1)
points(survival_probabilities_20_neg~resources,col="red")
points(survival_probabilities_10~resources,col="blue")
points(survival_probabilities_div6~resources,col="gold",pch=2)


# From Pablo: 2) I tried to solve the issue of population explosion, by exponentiating the survival costs with age, and the same with reproductive costs, so it would be more costly to survive/reproduce when you get older. However, this made crush the population in 2-3 iterations because the costs of survival/reproduction were too high when exponentiating. Do you think it is because the values are too high or am I missing something else? 

# From Dieter: Yes, exponentiating quickly leads to massive changes - e.g. if you start with survival of 0.75, the chance to survive to age 4 is 5%: 0.75*(0.75*0.75)*(0.75*0.75*0.75)*(0.75*0.75*0.75*0.75)

#Pablo: I am trying to plot the survival cost function, so that it increases with age. I think the one dividing by 20 should be smooth enough.

#survival cost only exp
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r <- exp(surv_c)
#survival costs for ages
surv_costs <- a*exp(r*ages)

#survival cost dividing by 20
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_20 <- exp(surv_c)/20
#survival costs for ages
surv_costs_20 <- a*exp(r_20*ages)

#survival cost dividing by 10
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_10 <- exp(surv_c)/10
#survival costs for ages
surv_costs_10 <- a*exp(r_10*ages)

#survival cost dividing by div6
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_div6 <- exp(surv_c/2)/6
#survival costs for ages
surv_costs_div6 <- a*exp(r_div6*ages)

plot(surv_costs_20~ages,xlim=c(0,100))
points(surv_costs_10~ages,col="blue")
points(surv_costs~ages,col="red")
points(surv_costs_div6~ages,col="gold",pch=2)

####

#age
age <- function(it_indpop){
  it_indpop$age[i] <- it_indpop$age[i]+it_indpop$surv[i]
  return(it_indpop$age)
}

#discount survival costs
survive_c <- function(it_indpop) {
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-surv_c_age[it_indpop$age[i]+1]
    return(it_indpop$prod_a)
  }
```

The functions for resource production and consumption are defined here. First is the probability of producing resources, then the amount of new resources, followed by the discount due to consumption. The production function tells if an individual produces new resources (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the production probability in the auxiliary variables.

```{r}
#production
produce <- function(it_indpop){
  it_indpop$prod_o[i] <- rbinom(1,1,prod_p)
  return(it_indpop$prod_o)
}

#adding resources produced
produce_a <- function(it_indpop) {
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n
  return(it_indpop$prod_a)
}

#consumption
consume <- function(it_indpop) {
  it_indpop$cons[i] <- cons
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons
  return(it_indpop)
}

#Dieter:
# For both though, i wonder whether you need to plan the functions more flexibly. If I understand it correctly, the production probability can change according to the stage the individual is in. So I think that this should be part of the function definition:

# produce <- function(ind,production_probability){
#  ind$prod<-rbinom(nrow(ind),1,production_probability)
#  return(ind)
# }

# The function can than be used as:
# produce(pop,prod_p)
# Where the prod_p can be adjusted according to the stage of the individuals. Though I assume if you end up having a population where individuals are in different stages, you presumably want to make this a two-step process:

# produce <- function(ind){
#  ind$proc_b<-ifelse(ind$age<6,proc_b_infant,ifelse(ind$age<15,proc_b_juvenile,0))  # I think there is some way to set this up better
#  ind$prod<-rbinom(nrow(ind),1,ind$proc_b)
#  return(ind)
# }

#Pablo:
#I think the last option sounds like the best. However, I thought the stage-specific probabilities were set as auxiliary variables, which is why I was not considering them in the function definitions. Is this a good way to do it? Do you think is necessary to solve it for this model, where individuals don't transition to another life cycle stage, or can it be dealt in the next one where individuals have two stages?

# Dieter:
# Yes, I think for now this works. I was already thinking ahead. You could have an additional setup where there are functions that adjust the probabilities accordingly. The way you have setup it up currently though, where functions are simultaneously applied to all individuals in a vector, makes me think that the second approach I am describing will be necessary. This is because not all individuals will transition at the same time, so there will be a mix of individuals in the data frame and the function needs to consider for each individual separately which stage it is in. Or are you assuming that when individuals transition they move to a new data frame, being killed from the dataframe for stage 1 and being added to the dataframe for stage 2?

#Pablo:
#I am thinking on what you said first, not the last part of individuals moving to a new data frame. Therefore, the functions will have to consider the stage of the individual to act differently. Also, stage-specific auxiliary variables (e.g. survival costs, amount of resources produced).

```

The functions for the reproductive dynamics are defined here. First the probability of reproducing is defined, followed by the reproductive costs, and adding the newborn in the population. The reproduction function tells if an individual reproduces (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the reproduction probability in the auxiliary variables (`repro_p`) and *weighted by the amount of resources produced (`it_indpop$prod_a`)*. 


```{r}
#reproduction probability
reproduce <- function(it_indpop){
  if(it_indpop$prod_a[i] >= repro_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(repro_p+log(it_indpop$prod_a[i]+1)/20)) {
  it_indpop$repro[i] <- 1
  }else{
  it_indpop$repro[i] <- 0
  }
  return(it_indpop$repro)
}

#reproductive costs
reproduce_c <- function(it_indpop) {
  if(it_indpop$repro[i] == 1){
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]
  }else{
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]
  }
    return(it_indpop$prod_a)
}

#adding the newborn
#new_ind <- function(it_indpop){
#  it_indpop <- rbind(it_indpop,data.frame(id=(max(it_indpop$id)+1):((max(it_indpop$id)+1)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"]))))
#  return(it_indpop)
#}

#this one did not work out well so I put it directly on the code for one iteration.
```

Now the functions are used in the 1000 individuals in the population for one iteration.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)

#I tried like a set up function instead of writing the whole data frame, but it messed up the id because it was giving everybody an id of 1000 instead of a number between 1 and 1000.

#run one iteration for all the population
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=c("1","1"))

#check the population by the end of the iteration
head(it_indpop)
```

Let's see how it looks like if you run 100 iterations.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)

#run 100 iterations
for (b in 1:100){
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=as.character(c(b-1,b)))
}

#check the population by the end of the iterations
head(it_indpop)

#check the age distribution by the end of the iterations
hist(it_indpop$age)
```

The functions should feed a database to record the life cycle and resource dynamics experienced by each individual in the population. Therefore, the database should record at each iteration if the individual survived, the amount of resources produced and consumed, and if reproduced. The database would contain the raw data necessary to calculate the different outcomes necessary to understand the relationship between resource dynamics and the variability of life cycles in a female human population.

# From Dieter: To understand it better, these functions will be applied each iteration of the previous loop? Are you only interested in the final (potentially stable) population at the end of the 100 iterations?

# Pablo: I think the answer to this question is that I want to do the massive database that you mentioned in the e-mail, for which I would need to apply these functions in each iteration of the previous loop, and I am not interested in analyzing only the final population at the end of the 100 iterations.

```{r}
#id
id_mult <- function(it_indpop_mult){
  it_indpop_mult$id[i] <- it_indpop$id[i]
  return(it_indpop_mult$id)
}

#survival
surv_mult <- function(it_indpop_mult){
  it_indpop_mult$surv_1[i] <- it_indpop$id[i]
  return(it_indpop_mult$id)
}

#total amount of successulf outcomes in production
produce_final_o <- function(final_indpop){
  final_indpop$prod_n[i] <- final_indpop$prod_n[i]+it_indpop$prod_o[i]
  return(final_indpop$prod_n)
}

#total amount of resources produced
produce_final_a <- function(final_indpop){
  final_indpop$prod[i] <- final_indpop$prod[i]+it_indpop$prod_a[i]
  return(final_indpop$prod)
}

#lifetime reproductive output
lro <- function(final_indpop){
  final_indpop$lro[i] <- final_indpop$lro[i]+it_indpop$repro[i]
  return(final_indpop$lro)
}

#age at ith reproduction
#age_repro_i <- function(final_indpop){
 # if(it_indpop$repro[i]==1){
  #final_indpop$age_repro_i[i] <- it_indpop$age[i]

  #}
#}

#Not sure how to make a new column with the age at subsequent reproductive events.

#average interbirth interval
#avg_ibi <- function(final_indpop){
  #final_indpop$ibi[i] <- (final_indpop$age_repro_i[i]-final_indpop$age_repro_i[i])/final_indpop$lro
  #return(final_indpop$ibi)
#}

#It should work depending on how the final_indpop$age_repro_i[i] can refer to the age at last and first reproduction.

````

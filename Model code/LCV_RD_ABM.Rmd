---
title: 'Life cycle variation and resource dynamics ABM: Code'
author: "Pablo J. Varas Enr√≠quez"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setlocale("LC_TIME", "C")
#install.packages("tidyverse")
library(tidyverse)
#install.packages("summarytools")
library(summarytools)
```

## Outline

The following code is meant to develop an agent-based model to understand how the resource dynamics of female individuals influence the variability of life cycles at the population level. For this, the following variables are needed in the model, at the individual and population levels:

| Level      | Life cycle                                     | Resource dynamic              |
|------------|------------------------------------------------|-------------------------------|
| Individual | Longevity                                      | Lifetime production events    |
|            | Lifetime reproductive output                   | Lifetime resource production  |
|            | Age at first reproduction                      | Lifetime consumption events   |
|            | Age at last reproduction                       | Lifetime resource consumption |
|            | Average interbirth interval                    | Lifetime storage events       |
|            | Age at life cycle stage transition             | Lifetime resource storage     |
|            |                                                | Lifetime giving events        |
|            |                                                | Lifetime resource given       |
|            |                                                | Lifetime recieving events     |
|            |                                                | Lifetime resource recieved    |
| Population | Longevity variability                          |                               |
|            | Lifetime reproductive output variability       |                               |
|            | Age at first reproduction variability          |                               |
|            | Age at last reproduction variability           |                               |
|            | Average interbirth interval variability        |                               |
|            | Age at life cycle stage transition variability |                               |

At first, there is a section called "Starting point", which are the first attempts and checks of the model. Different modules are used to build the initial states of the model, with less life cycle stages and resource dynamics. Once few modules work, more modules will be developed and included in the model. The starting point has one life cycle, and two resource dynamics (i.e. production, consumption), and builds-up from there. Here, the values used are not necessarily realistic since they are intended to help building the different modules.

The following sections are the different scenarios where the model will be used. The values used in these scenarios are based on cross-cultural research. The scenarios are:

1.  A population where all individuals have medium probabilities of resource production and sharing.
2.  A population where all individuals have high probabilities for resource production and sharing.
3.  A population where most individuals (75% of the population) have a high probability of production and low probability of sharing. The rest (25%) have medium probabilities for production and sharing.
4.  A population where most individuals (75% of the population) have a low probability of production and high probability of sharing. The rest (25%) have medium probabilities for production and sharing.
5.  A population where all individuals have low probabilities for resource production and sharing.

### Starting point

The starting point section consists of the development of the different modules that will be used to build the final model. First, it will be the module for individuals in their reproductive career stage and the resource dynamics of production and consumption (i.e. one life cycle stage, two resource dynamics). Second, one with two life cycle stages (i.e. infant, reproductive career), production, consumption, and storage. Third, adult and post-reproductive stages will be added, and finally, with the dynamics. Accordingly, the final model will have individuals going through four life stages (infant, adult, reproductive, post-reproductive) and in each experiencing three different resource dynamics (production, sharing, storage).

#### First attempt: one life cycle stage, two resource dynamics.

An agent-based model is developed here with a population of 1000 individuals that have only one life cycle stage (i.e. reproductive career) and experience two resource dynamics (i.e. production and consumption). All individuals start with the maximum amount of resources that can be produced in one iteration (1) to ensure they can survive at initialisation.

First, the auxiliary variables are defined for the model. Auxiliary variables are fixed values set at initialisation that define the life-history and resource dynamics that individuals can experience. Regarding life-history dynamics, you define:

-   Dying probability (`die_p`).
-   Survival cost (`surv_c`).
-   Age-specific cost (`surv_c_age`).
-   Reproduction probability (`repro_p`).
-   Cost of reproduction (`repro_c`).
-   Age-specific cost of reproduction (`repro_c_age`).
-   Number of descendants per reproduction (`repro_n`).

Regarding resource dynamics, the auxiliary variables are:

-   Probability of production (`prod_p`).
-   Amount of resources produced (`prod_n`).
-   Amount of resources consumed (`cons_n`).

```{r}
#survival
#age-specific probability of dying
die_p_age <- c(0.11 , 0.08 , 0.06, 0.04, 0.03, seq(0.01, 0.1,length.out=70), seq(0.1,1, length.out=26))
#cost of surviving
surv_c <- 0.25
#age-specific cost of surviving
surv_c_age <- c(surv_c,surv_c*exp(exp(surv_c)/20*c(1:100))) 

#reproduction
#age-specific fertility probability
repro_p_age <- c(rep(0.0,15), seq(0.01,0.3, length.out=15), seq(0.3,0.01, length.out=15), rep(0,55))
#cost of reproduction
repro_c <- 0.25
#age-specific cost of reproduction
repro_c_age <- c(repro_c,repro_c*exp(exp(repro_c)/20*c(1:100)))
#number of descendants per reproduction
repro_n <- 1

#production
#probability
prod_p <- 0.5
#amount of resources produced
prod_n <- 1

#consumption
#amount of resources consumed
cons <- 0.25
```

The functions for state variables are defined to determine the dynamics each individual can experience in one year (i.e. one iteration). The functions for survival and age are defined first, followed by the discount on the amount of resources available due to the costs of survival. An individual can either survive (1) or not (0) in the survival function. An individual can survive (1) depending if the individual has enough resources to cover the age-specific costs of survival (`surv_c_age`) and samples from a uniform distribution a value lower than the sum of the probability of surviving (`die_p`) and the logarithm of the amount of resources available (`prod_a`). The influence of the amount of resources available is escaled to avoid an explosive population growth.

```{r}
#survival
survive <- function(it_indpop){
  if(it_indpop$prod_a[i] >= surv_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)>(die_p_age[it_indpop$age[i]+1]+log(it_indpop$prod_a[i]+1)/20)){
  it_indpop$surv[i] <- 1
  }
  else{
  it_indpop$surv[i] <- 0
  }
  return(it_indpop$surv)
}

#Pablo:
#I think a solution for the "weighting" problem is to make the survival depend on having the resources or not, so if you don't have the resources you definitely die, and if you have them you go through the random option of surviving or not.
# From Dieter: I think this goes back to the discussion in the TICEL meeting, about the function that links inputs to outputs. To me, for survival, there are two steps: first, assign an individual specific level of survival depending on the resources. So there is a function that links resources to a probability. Maybe the easiest is something similar to what you have: when resources are below a critical threshold, individuals will definitely die; if resources reach that threshold, there is a baseline survival probability; if individuals have more resources, their survival probability increases. That increase probably follows a logarithmic function, with additional resources leading to smaller increases. The second step is that we draw a random number for this individual between 0 and 1 (runif(1,min=0,max=1)) and see whether that number is smaller than the probability to survive. Here is such a suggestion. I am dividing the log benefit by 20 to bring it onto the relevant scale - so if the baseline survival is 0.75, and individual with 100 resources will now have a survival of 0.75 + log(100)/20 = 0.75 + 0.23 = 0.98. With this example, most individuals survive, so if you use this variant without changing anything else, the population will explode.
#Pablo: I changed the survival function to what you suggest and I think it clearly nails the discussion in the TICEL meeting. I have two questions: 1) why is it necessary to divide by 20 to bring it onto the relevant scale? and 

# From Dieter:
# It might be useful to plot the functions to get an idea of how it influences the baseline probability. For example, should the baseline be the average or should it be the starting point? Should there be a steep incline or just a small change? Should the change be abrupt or gradual across the whole range? It also matters how you measure resources (are they measured in units of 1 or smaller units, what could the maximum be etc.) Here are four options that illustrate these differences based on what you set above that the production of resources is ~0.5 - so small steps and going up to a maximum of 10 resources (40 steps of production with baseline production (0.5) + consumption (0.25) - 40*0.25=10). I think you will probably decide the shape depending on the references you wanted to use? 

#Pablo:
#If I understand correctly, dividing by 20 is to make the survival probability have values below one, right? I updated the code below then so the baseline production is 1 (0.5 is the probability of producing one resource), the resources vector would have a maximum of 75 resources (100 steps of production with baseline production (1) + consumption (0.25), 100*0.75=75), and I divide by 20, 20_neg, 10, and the dive6.

# 
resources<-seq(from=0,to=75,length.out=101)
survival_probabilities_20<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20[i]<-0}else{survival_probabilities_20[i]<-die_p+log(resources[i]+1)/20}
}

survival_probabilities_20_neg<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20_neg[i]<-0}else{survival_probabilities_20_neg[i]<-die_p+log(resources[i])/20}
}

survival_probabilities_10<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_10[i]<-0}else{survival_probabilities_10[i]<-die_p+log(resources[i]+1)/10}
}

survival_probabilities_div6<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_div6[i]<-0}else{survival_probabilities_div6[i]<-die_p+(log(resources[i]/2)/6) }
}

plot(survival_probabilities_20~resources,xlim=c(0,75),ylim=c(0,1.3))
abline(h=1)
points(survival_probabilities_20_neg~resources,col="red")
points(survival_probabilities_10~resources,col="blue")
points(survival_probabilities_div6~resources,col="gold",pch=2)


# From Pablo: 2) I tried to solve the issue of population explosion, by exponentiating the survival costs with age, and the same with reproductive costs, so it would be more costly to survive/reproduce when you get older. However, this made crush the population in 2-3 iterations because the costs of survival/reproduction were too high when exponentiating. Do you think it is because the values are too high or am I missing something else? 

# From Dieter: Yes, exponentiating quickly leads to massive changes - e.g. if you start with survival of 0.75, the chance to survive to age 4 is 5%: 0.75*(0.75*0.75)*(0.75*0.75*0.75)*(0.75*0.75*0.75*0.75)

#Pablo: I am trying to plot the survival cost function, so that it increases with age. I think the one dividing by 20 should be smooth enough.

#survival cost only exp
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r <- exp(surv_c)
#survival costs for ages
surv_costs <- a*exp(r*ages)

#survival cost dividing by 20
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_20 <- exp(surv_c)/20
#survival costs for ages
surv_costs_20 <- a*exp(r_20*ages)

#survival cost dividing by 10
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_10 <- exp(surv_c)/10
#survival costs for ages
surv_costs_10 <- a*exp(r_10*ages)

#survival cost dividing by div6
#age
ages<-1:100
#surv cost at age 0
a <- 0.25 
#constant exponential growth
r_div6 <- exp(surv_c/2)/6
#survival costs for ages
surv_costs_div6 <- a*exp(r_div6*ages)

plot(surv_costs_20~ages,xlim=c(0,100))
points(surv_costs_10~ages,col="blue")
points(surv_costs~ages,col="red")
points(surv_costs_div6~ages,col="gold",pch=2)

####

#age
age <- function(it_indpop){
  it_indpop$age[i] <- it_indpop$age[i]+it_indpop$surv[i]
  return(it_indpop$age)
}

#discount survival costs
survive_c <- function(it_indpop) {
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-surv_c_age[it_indpop$age[i]+1]
    return(it_indpop$prod_a)
  }
```

The functions for resource production and consumption are defined here. First is the probability of producing resources, then the amount of new resources, followed by the discount due to consumption. The production function tells if an individual produces new resources (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the production probability in the auxiliary variables.

```{r}
#production
produce <- function(it_indpop){
  it_indpop$prod_o[i] <- rbinom(1,1,prod_p)
  return(it_indpop$prod_o)
}

#adding resources produced
produce_a <- function(it_indpop) {
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n
  return(it_indpop$prod_a)
}

#consumption
consume <- function(it_indpop) {
  it_indpop$cons[i] <- cons
  it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons
  return(it_indpop)
}

#Dieter:
# For both though, i wonder whether you need to plan the functions more flexibly. If I understand it correctly, the production probability can change according to the stage the individual is in. So I think that this should be part of the function definition:

# produce <- function(ind,production_probability){
#  ind$prod<-rbinom(nrow(ind),1,production_probability)
#  return(ind)
# }

# The function can than be used as:
# produce(pop,prod_p)
# Where the prod_p can be adjusted according to the stage of the individuals. Though I assume if you end up having a population where individuals are in different stages, you presumably want to make this a two-step process:

# produce <- function(ind){
#  ind$proc_b<-ifelse(ind$age<6,proc_b_infant,ifelse(ind$age<15,proc_b_juvenile,0))  # I think there is some way to set this up better
#  ind$prod<-rbinom(nrow(ind),1,ind$proc_b)
#  return(ind)
# }

#Pablo:
#I think the last option sounds like the best. However, I thought the stage-specific probabilities were set as auxiliary variables, which is why I was not considering them in the function definitions. Is this a good way to do it? Do you think is necessary to solve it for this model, where individuals don't transition to another life cycle stage, or can it be dealt in the next one where individuals have two stages?

# Dieter:
# Yes, I think for now this works. I was already thinking ahead. You could have an additional setup where there are functions that adjust the probabilities accordingly. The way you have setup it up currently though, where functions are simultaneously applied to all individuals in a vector, makes me think that the second approach I am describing will be necessary. This is because not all individuals will transition at the same time, so there will be a mix of individuals in the data frame and the function needs to consider for each individual separately which stage it is in. Or are you assuming that when individuals transition they move to a new data frame, being killed from the dataframe for stage 1 and being added to the dataframe for stage 2?

#Pablo:
#I am thinking on what you said first, not the last part of individuals moving to a new data frame. Therefore, the functions will have to consider the stage of the individual to act differently. Also, stage-specific auxiliary variables (e.g. survival costs, amount of resources produced).

```

The functions for the reproductive dynamics are defined here. First the probability of reproducing is defined, followed by the reproductive costs. The reproduction function tells if an individual reproduces (1) or not (0). An individual reproduces (1) depending if the individual has enough resources to cover the age-specific costs of reproduction (`repro_c_age`)and samples from a uniform distribution a value lower than the sum of the probability of reproducing (`repro_p`) and the logarithm of the amount of resources available (`prod_a`). The influence of the amount of resources available is scaled to avoid an explosive population growth.

```{r}
#reproduction probability
reproduce <- function(it_indpop){
  if(it_indpop$prod_a[i] >= repro_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(repro_p_age[it_indpop$age[i]+1]+log(it_indpop$prod_a[i]+1)/20)) {
  it_indpop$repro[i] <- 1
  }else{
  it_indpop$repro[i] <- 0
  }
  return(it_indpop$repro)
}

#reproductive costs
reproduce_c <- function(it_indpop) {
  if(it_indpop$repro[i] == 1){
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]
  }else{
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]
  }
    return(it_indpop$prod_a)
}

#adding the newborn
#new_ind <- function(it_indpop){
#  it_indpop <- rbind(it_indpop,data.frame(id=(max(it_indpop$id)+1):((max(it_indpop$id)+1)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"]))))
#  return(it_indpop)
#}

#this one did not work out well so I put it directly on the code for one iteration.
```

Now that the life-history and resource dynamics functions are defined. They are used in a population of 1000 individuals only for one year. Additionally, two datasets are created to record the dynamics for each individual during one year (`it_indpop`) as well as record them through time (`it_data`). Other datasets are used to feed `it_data`, which are based on the survival outcome (`surv_data`), resource production (`resource_data`), and reproduction (`repro_data`). Consumption is not recorded through time because it is a fixed value.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)

#run one iteration for all the population
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=c("0","1"))

#check the population by the end of the iteration
head(it_indpop)
#check the recorded data by the end of the iteration
head(it_data)
```

After checking that the functions and databases work for one year, the model can be run for more years. Here we run the simulations for a 100 of years, resembling one generation of a population.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)

#run 100 iterations
for (b in 1:100){
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$prod_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=as.character(c(b-1,b)))
}

#check the population by the end of the iterations
head(it_indpop)

#check the age distribution by the end of the iterations
hist(it_indpop$age)
```

Now that there is a record for the survival, reproduction, and resource dynamics of each individual every year, it is possible to create the functions to calculate the different life-history traits and resource-dynamics of interest for each individual:

-   Longevity: number of years from birth to death.
-   Lifetime reproductive output (LRO): total number of descendants.
-   Age at first reproduction (AFR): age at which the individual has her first descendant.
-   Age at last reproduction (ALR): age at which the individual has her last descendant.

```{r}
#longevity
longevity <- function(final_ind_data){
  final_ind_data$lng[i] <- as.numeric(rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
  return(final_ind_data$lng)
}

#LRO
lro <- function(final_ind_data){
  final_ind_data$lro[i] <- as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T))
  return(final_ind_data$lro)
}

#AFR
afr <- function(final_ind_data){
  if(final_ind_data$lro[i] == 0){
    final_ind_data$afr[i] <- NA 
  }else{
    final_ind_data$afr[i] <-
    min(cumsum(it_data[i,grep("surv",colnames(it_data))][!is.na(it_data[i,grep("surv",colnames(it_data))])])[it_data[i,grep("repro",colnames(it_data))][!is.na(it_data[i,grep("repro",colnames(it_data))])]==1])
  }
  return(final_ind_data$afr)
}

#ALR
alr <- function(final_ind_data){
 if(final_ind_data$lro[i] == 0){
    final_ind_data$alr[i] <- NA 
  }else{
    final_ind_data$alr[i] <-
    max(cumsum(it_data[i,grep("surv",colnames(it_data))][!is.na(it_data[i,grep("surv",colnames(it_data))])])[it_data[i,grep("repro",colnames(it_data))][!is.na(it_data[i,grep("repro",colnames(it_data))])]==1])
  }
  return(final_ind_data$alr)
}
```

The functions for the lifetime resource dynamics of each individual are developed below. The dynamics that would be calculated are:

-   Lifetime production events: total number of positive outcomes (1) from the production function during the lifetime of an individual.
-   Lifetime resource production: total amount of resources produced during the lifetime of an individual.
-   Lifetime consumption events: total number of consumption events during the lifetime of an individual. This amount should be the same as the age of an individual since consumption is fixed.
-   Lifetime resource consumption: total amount of resources consumed during the lifetime of an individual.
-   Lifetime resources available: total amount of resources available during the lifetime of an individual.
-   Average resources available: average amount of resources available during the lifetime of an individual.
-   Variability resources available: variance of the amount of resources available during the lifetime of an individual.

```{r}
#production events
production_ev <- function(final_ind_data){
  final_ind_data$prod_ev[i] <- as.numeric(rowSums(it_data[i,grep("prod_o",colnames(it_data))],na.rm = T))
  return(final_ind_data$prod_ev)
}

#resource production
production_res <- function(final_ind_data){
  final_ind_data$prod_res[i] <- final_ind_data$prod_ev[i]*prod_n 
  return(final_ind_data$prod_res)
}

#consumption events
consumption_ev <- function(final_ind_data){
  final_ind_data$cons_ev[i] <- final_ind_data$lng[i]
  return(final_ind_data$cons_ev)
}

#resource consumption
consumption_res <- function(final_ind_data){
  final_ind_data$cons_res[i] <- final_ind_data$cons_ev[i]*cons
  return(final_ind_data$cons_res)
}

#lifetime resources available
l_resources_av <- function(final_ind_data){
  final_ind_data$l_res_av[i] <- as.numeric(rowSums(it_data[i,grep("prod_a",colnames(it_data))],na.rm=T))
  return(final_ind_data$l_res_av)
}
  
#average resources available
a_resources_av <- function(final_ind_data){
  final_ind_data$a_res_av[i] <- mean(as.numeric(it_data[i,grep("prod_a",colnames(it_data))]),na.rm = T)
  return(final_ind_data$a_res_av)
}

#variance resources available
v_resources_av <- function(final_ind_data){
  final_ind_data$v_res_av[i] <- var(as.numeric(it_data[i,grep("prod_a",colnames(it_data))]),na.rm = T)
  return(final_ind_data$v_res_av)
  }
```

Once the functions to calculate the life-history traits and resource dynamics for each individual, it is possible to use them in the individuals from the population that was simulated for 100 years (`it_data`). The calculations for each individual are recorded in a separate database (`final_ind_data`).

```{r}
#create dataset
final_ind_data <- data.frame(id=1:nrow(it_data))

for(i in 1:nrow(it_data)){
  #life-history traits
  #longevity
final_ind_data$lng <- longevity(final_ind_data)
  #lro
final_ind_data$lro <- lro(final_ind_data)
  #afr
final_ind_data$afr <- afr(final_ind_data)
  #alr
final_ind_data$alr <- alr(final_ind_data)
  #resource dynamics
  #production events
final_ind_data$prod_ev <- production_ev(final_ind_data)
  #resource production
final_ind_data$prod_res <- production_res(final_ind_data)
  #consumption events
final_ind_data$cons_ev <- consumption_ev(final_ind_data)
  #resource consumption
final_ind_data$cons_res <- consumption_res(final_ind_data)
  #lifetime resources available
final_ind_data$l_res_av <- l_resources_av(final_ind_data)
  #average resources available
final_ind_data$a_res_av <- a_resources_av(final_ind_data)
  #variance resources available
final_ind_data$v_res_av <- v_resources_av(final_ind_data)
}

#plot it
#plot distributions of life-history traits
par(mfrow=c(2,2))
hist(final_ind_data$lng)
hist(final_ind_data$lro)
hist(final_ind_data$afr)
hist(final_ind_data$alr)
#plot distributions of resource dynamics
layout(matrix(c(1,1,2,2,3,3,4,4,0,5,5,6,6,7,7,0),nrow=2,byrow=TRUE))
hist(final_ind_data$prod_ev)
hist(final_ind_data$prod_res)
hist(final_ind_data$cons_ev)
hist(final_ind_data$cons_res)
hist(final_ind_data$l_res_av)
hist(final_ind_data$a_res_av)
hist(final_ind_data$v_res_av)
#pairwise relationship 
pairs(~lng+lro+afr+alr+prod_ev+prod_res+cons_ev+cons_res+l_res_av+a_res_av+v_res_av,data=final_ind_data)
#pairwise relationship of life-history traits with resource availability measurements
pairs(~lng+lro+afr+alr+l_res_av+a_res_av+v_res_av,data=final_ind_data)
```

*Not so sure about calculating the summary statistics*

Once the life-history traits and resource dynamics are calculated for each individual, it is possible to estimate the variability of life cycles at the population level. The variables are:

-   Longevity variability
-   Lifetime reproductive output variability
-   Age at first reproduction variability
-   Age at last reproduction variability

Different summary statistics are used to describe the life cycles in the population. The description includes the mean, variance, standard deviation, coefficient of variation, skewness, kurtosis, minimum/maximum value, and quartiles.

```{r}
#summary statistics
#descr(final_ind_data[,2:6],stats = c("mean","sd","min","q1","med","q3","max","cv","skewness","kurtosis"),order = "p")
#variance
#data.frame(lng=var(final_ind_data$lng),lro=var(final_ind_data$lro),afr=var(final_ind_data$afr,na.rm=T),alr=var(final_ind_data$alr,na.rm=T),ibi=var(final_ind_data$ibi,na.rm=T),row.names = c("Var"))
```

#### Second attempt: two life cycle stages, three resource dynamics.

An agent-based model is developed here with a population of 1000 individuals that have two life cycle stages (i.e. juvenile, reproductive career) and experience three resource dynamics (i.e. production, consumption, storage). The initial population will be half juveniles (n=500) and half individuals in their reproductive careers (n=500). All individuals start with the maximum amount of resources that can be produced in one iteration (1) to ensure they can survive at initialisation.

First, the auxiliary variables are defined for the model. Auxiliary variables are fixed values set at initialisation that define the life-history and resource dynamics that individuals can experience. Regarding life-history dynamics, they are stage-specific and defined as:

-   Dying probability (`die_p`).
-   Age-specific dying probability (`die_p_age`)
-   Survival cost (`surv_c`).
-   Age-specific survival cost (`surv_c_age`).
-   Reproduction probability (`repro_p`) - reproductive career only.
-   Cost of reproduction (`repro_c`) - reproductive career only.
-   Age-specific cost of reproduction (`repro_c_age`) - reproductive career only.
-   Number of descendants per reproduction (`repro_n`) - reproductive career only.

Regarding resource dynamics, the auxiliary variables are also stage-specific and are defined as:

-   Probability of production (`prod_p`).
-   Amount of resources produced (`prod_n`).
-   Amount of resources consumed (`cons_n`).
-   Probability of storage (`store_p`).

```{r}
#juvenile

#survival
#age-specific probability of dying
die_p_age <- c(0.11 , 0.08 , 0.06, 0.04, 0.03, seq(0.01, 0.1,length.out=70), seq(0.1,1, length.out=26))
#cost of surviving
surv_c <- 0.25
#age-specific cost of surviving
surv_c_age <- c(surv_c,surv_c*exp(exp(surv_c)/20*c(1:100))) 

#production
#probability
prod_p_juv <- 0.5
#amount of resources produced
prod_n_juv <- 1

#consumption
#amount of resources consumed
cons_juv <- 0.25

#storage
#probability of storage
store_p_juv <- 0.9

#reproduction
#age-specific fertility probability
repro_p_age <- c(rep(0.0,15), seq(0.01,0.3, length.out=15), seq(0.3,0.01, length.out=15), rep(0,55))
#cost of reproduction
repro_c <- 0.25
#age-specific cost of reproduction
repro_c_age <- c(repro_c,repro_c*exp(exp(repro_c)/20*c(1:100)))
#number of descendants per reproduction
repro_n <- 1

#production
#probability
prod_p_rc <- 0.5
#amount of resources produced
prod_n_rc <- 2

#consumption
#amount of resources consumed
cons_rc <- 0.5

#storage
#probability of storage
store_p_rc <- 0.75
```

Now, the functions for the state variables are defined. First are the functions for life-history dynamics, followed by the ones related to resource dynamics. Each function is defined specifically for each life cycle stage. The functions for survival and age are defined first, followed by the discount on the amount of resources available due to the costs of survival. An individual can either survive (1) or not (0) in the survival function. An individual can survive (1) depending if the individual has enough resources to cover the age-specific costs of survival (`surv_c_age`) and samples from a uniform distribution a value lower than the sum of the age-specific probability of surviving (`die_p`) and the logarithm of the amount of resources stored (`store_a`). The influence of the amount of resources stored is escaled to avoid an explosive population growth.

```{r}
#survival
survive <- function(it_indpop){
  if(it_indpop$store_a[i] >= surv_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)>(die_p_age[it_indpop$age[i]+1]+log(it_indpop$store_a[i]+1)/20)){
      it_indpop$surv[i] <- 1
    } else{
      it_indpop$surv[i] <- 0
    }
  return(it_indpop$surv)
}

#age
age <- function(it_indpop){
  it_indpop$age[i] <- it_indpop$age[i]+it_indpop$surv[i]
  return(it_indpop$age)
}

#survival costs discount from stored resources
survive_c <- function(it_indpop){
    it_indpop$store_a[i] <- it_indpop$store_a[i]-surv_c_age[it_indpop$age[i]+1]
  return(it_indpop$store_a)
}

```

The functions for resource production, consumption, and storage are defined here. First is the probability of producing resources, then the amount of new resources, followed by the discount due to consumption, and the probability of storing the resources available or not. The production and storage functions tell if an individual produces/storage new resources (1) or not (0), based on a binomial distribution. The probability in the binomial distribution is defined by the production and storage probabilities in the auxiliary variables, respectively.

```{r}
#production
produce <- function(it_indpop){
  if(it_indpop$stage[i]==0){ #juvenile
    it_indpop$prod_o[i] <- rbinom(1,1,prod_p_juv)
  } else{ #reproductive career
    it_indpop$prod_o[i] <- rbinom(1,1,prod_p_rc)
  }
    return(it_indpop$prod_o)
}

#adding resources produced to resources available
produce_a <- function(it_indpop){
  if(it_indpop$stage[i]==0){ #juvenile
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n_juv
  } else{ #reproductive career
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n_rc
  }
    return(it_indpop$prod_a)
}

#consumption
consume <- function(it_indpop){
  if(it_indpop$stage[i]==0){ #juvenile
    it_indpop$cons[i] <- cons_juv
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons_juv
  } else{ #reproductive career
    it_indpop$cons[i] <- cons_rc
    it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons_rc
  }
  return(it_indpop)
}

#storage
store <- function(it_indpop){
  if(it_indpop$stage[i]==0){ #juvenile
    it_indpop$store_o[i] <- rbinom(1,1,store_p_juv)
  } else{ #reproductive career
    it_indpop$store_o[i] <- rbinom(1,1,store_p_rc)
  }
    return(it_indpop$store_o)
}

#adding stored resources
store_a <- function(it_indpop) {
  it_indpop$store_a[i] <- it_indpop$store_a[i]+it_indpop$store_o[i]*it_indpop$prod_a[i]
  it_indpop$prod_a[i] <- 0
  return(it_indpop)
}
```

The functions for the reproductive dynamics are defined here. This function is only for those individuals in the reproductive career stage. First the probability of reproducing is defined, followed by the reproductive costs. The reproduction function tells if an individual reproduces (1) or not (0). An individual reproduces (1) depending if the individual has enough resources to cover the age-specific costs of reproduction (`repro_c_age_rc`)and samples from a uniform distribution a value lower than the sum of the probability of reproducing (`repro_p_rc`) and the logarithm of the sum of resources availabledue to production (`prod_a`) and stored (`store_a`). The influence of the amount of resources available is scaled to avoid an explosive population growth.

```{r}
#reproduction probability
reproduce <- function(it_indpop){
  if(it_indpop$stage[i]==0){ #juvenile
    if(it_indpop$prod_a[i]+it_indpop$store_a[i] >= surv_c_age[it_indpop$age[i]+1]+repro_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(repro_p_age[it_indpop$age[i]+1]+log(it_indpop$prod_a[i]+it_indpop$store_a[i]+1)/20)){
      it_indpop$repro[i] <- 1
    } else{
      it_indpop$repro[i] <- 0
    }
  } else{ #reproductive career
    if(it_indpop$prod_a[i]+it_indpop$store_a[i] >= repro_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(repro_p_age[it_indpop$age[i]+1]+log(it_indpop$prod_a[i]+it_indpop$store_a[i]+1)/20)) {
      it_indpop$repro[i] <- 1
    } else{
      it_indpop$repro[i] <- 0
    }
  }
  return(it_indpop$repro)
}

#age-specific reproductive costs discount
reproduce_c <- function(it_indpop) {
  if(it_indpop$repro[i] == 0){
    it_indpop$prod_a <- it_indpop$prod_a
    it_indpop$store_a <- it_indpop$store_a
  }else{
    if(it_indpop$repro[i] == 1 & it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]>=0){
      it_indpop$prod_a[i] <- it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]
    }else{
      it_indpop$store_a[i] <- it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]+it_indpop$store_a[i]
    }
  }
  return(it_indpop)
}
```

The function for the life cycle stage transition is defined here. The transition from juvenile to reproductive career stage is defined by the age at first reproduction. The life cycle stage transition would depend on whether the individual reproduces or not in the iteration (`repro`). The costs of transition are included in the reproduction function.

```{r}
#transition
transition <- function(it_indpop){
  if(it_indpop$stage[i] == 0){ #juvenile
    if(it_indpop$repro[i] == 0){
    it_indpop$stage[i] <- it_indpop$stage[i]  
    } else{
    it_indpop$stage[i] <- 1  
    }
  } else{ #reproductive career
    it_indpop$stage[i] <- it_indpop$stage[i]
  }
  return(it_indpop$stage)
}

#Dieter:

# We plot the reproductive costs, based on the function you specified
plot(repro_c_age_rc)
# We plot the survival costs, based on the function you specified
points(die_p_age_juv*100,col="blue")
# We plot the resource availability based on your settings: this assumes that individuals produce 1 resource and consume 0.25 resource every year; when they are juveniles they store 90% of this, while when they are adults they use/loose everything. With that, initially resources go up (0.75 * 0.9 each year), and after that they stay the same. I assumed that growth (resource storage) stops at age 16.
points(c(cumsum(rep(0.9*0.75,16)),rep(11,84)),col="red")
# For illustration, we add lines that show that ages at transitions. These are when the resources are larger than the costs. For illustration here, I am taking the larger of the two costs, not the sum of the costs
abline(v=14,lty=2,lwd=2)
abline(v=60,lty=2,lwd=2)
# Add a legend and some labels
legend(x="topleft", legend=c(pch1="survival costs", pch1="resources",pch1="reproduction costs"), pch=c(1,1,1),col=c("blue","red","black"), box.lty=1, cex=1)
mtext("Age",side=1,line=3,cex=2)
mtext("Resources",side=2,line=2,cex=2)
mtext("Transition to Start Reproduction",side=1,line=-7,at=34,cex=1)
mtext("Transition to Stop Reproduction",side=1,line=-10,at=81,cex=1)
```

Now that the life-history and resource dynamics functions are defined. They are used in a population of 1000 individuals only for one year. The population is structured by half of them in a juvenile stage (n=500) and half in their reproductive career stage (n=500). Additionally, two datasets are created to record the dynamics for each individual during one year (`it_indpop`) as well as record them through time (`it_data`). Other datasets are used to feed `it_data`, which are based on the survival outcome (`surv_data`), resource dynamics (`resource_data`), and reproduction (`repro_data`).

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=c(rep(0,length.out=500),rep(15,length.out=500)),prod_o=rep(NA,length.out=1000),prod_a=rep(0,length.out=1000),cons=rep(NA,length.out=1000),store_o=rep(NA,length.out=1000),store_a=rep(2,length.out=1000),repro=rep(NA,length.out=1000),stage=c(rep(0,length.out=500),rep(1,length.out=500)))
#create iteration record
it_data <- data.frame(id=1:1000)

#run one iteration for all the population
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#record life cycle stage of every individual
trans_data1 <- it_indpop[,c("id","stage")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$store_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop <- reproduce_c(it_indpop)
  #transition
  it_indpop$stage <- transition(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a","cons")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#record life cycle stage
trans_data2 <- it_indpop[,c("id","stage")]
#merge life cycle stage data
trans_data <- merge(trans_data1,trans_data2,by="id",all=T)
#change NAs into life cycle stage
trans_data[is.na(trans_data$stage.y),"stage.y"] <- trans_data[is.na(trans_data$stage.y),"stage.x"]
#clean life cycle stage data
trans_data <- trans_data[,c("id","stage.y")]
colnames(trans_data)[2] <- "stage"
#calculate storage
for (i in 1:nrow(it_indpop)){
  #storage outcome
  it_indpop$store_o <- store(it_indpop)
  #storage amount
  it_indpop <- store_a(it_indpop)
}
#record resource storage
resource_data[,c("store_o","store_a")] <- it_indpop[,c("store_o","store_a")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),store_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),store_a=rep(2,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),stage=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data,trans_data),full_join,by="id",suffix=c("0","1"))

#check the population by the end of the iteration
head(it_indpop)
#check the recorded data by the end of the iteration
head(it_data)
```

After checking that the functions and databases work for one year, the model can be run for more years. Here we run the simulations for a 100 of years, resembling one generation of a population.

```{r}
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=c(rep(0,length.out=500),rep(15,length.out=500)),prod_o=rep(NA,length.out=1000),prod_a=rep(0,length.out=1000),cons=rep(NA,length.out=1000),store_o=rep(NA,length.out=1000),store_a=rep(2,length.out=1000),repro=rep(NA,length.out=1000),stage=c(rep(0,length.out=500),rep(1,length.out=500)))
#create iteration record
it_data <- data.frame(id=1:1000)

#run 100 iterations
for (b in 1:100){
for (i in 1:nrow(it_indpop)){
  #survival
  it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#record life cycle stage of every individual
trans_data1 <- it_indpop[,c("id","stage")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
  #age
  it_indpop$age <- age(it_indpop)
  #survival cost
  it_indpop$store_a <- survive_c(it_indpop)
  #production outcome
  it_indpop$prod_o <- produce(it_indpop)
  #production amount
  it_indpop$prod_a <- produce_a(it_indpop)
  #consumption
  it_indpop <- consume(it_indpop)
  #reproduction probability
  it_indpop$repro <- reproduce(it_indpop)
  #reproductive cost
  it_indpop <- reproduce_c(it_indpop)
  #transition
  it_indpop$stage <- transition(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a","cons")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#record life cycle stage
trans_data2 <- it_indpop[,c("id","stage")]
#merge life cycle stage data
trans_data <- merge(trans_data1,trans_data2,by="id",all=T)
#change NAs into life cycle stage
trans_data[is.na(trans_data$stage.y),"stage.y"] <- trans_data[is.na(trans_data$stage.y),"stage.x"]
#clean life cycle stage data
trans_data <- trans_data[,c("id","stage.y")]
colnames(trans_data)[2] <- "stage"
#calculate storage
for (i in 1:nrow(it_indpop)){
  #storage outcome
  it_indpop$store_o <- store(it_indpop)
  #storage amount
  it_indpop <- store_a(it_indpop)
}
#record resource storage
resource_data[,c("store_o","store_a")] <- it_indpop[,c("store_o","store_a")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),store_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),store_a=rep(2,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),stage=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data,trans_data),full_join,by="id",suffix=as.character(c(b-1,b)))
}

#check the population by the end of the iterations
head(it_indpop)

#check the age distribution by the end of the iterations
hist(it_indpop$age)
```

Now that there is a record for the survival, reproduction, life cycle stage, and resource dynamics of each individual every year, it is possible to create the functions to calculate the different life-history traits and resource-dynamics of interest for each individual:

-   Longevity: number of years from birth to death.
-   Lifetime reproductive output (LRO): total number of descendants.
-   Age at first reproduction (AFR): age at which the individual has her first descendant. For individuals that are in their reproductive career stage at initialisation, it would be the age at their next descendant.
-   Age at last reproduction (ALR): age at which the individual has her last descendant.
-   Age at life cycle stage transition: age at which the individual transition from juvenile to reproductive career.

```{r}
#longevity
longevity <- function(final_ind_data){
  final_ind_data$lng[i] <- as.numeric(rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
  return(final_ind_data$lng)
}

#LRO
lro <- function(final_ind_data){
  if(it_data$stage1[i]==1){
    final_ind_data$lro[i] <- as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T)) + 1 #you must have one descendant to be in the reproductive career stage
  } else{
    final_ind_data$lro[i] <- as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T))
  }
  return(final_ind_data$lro)
}

#AFR
afr <- function(final_ind_data){
  if(as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T)) == 0){
    final_ind_data$afr[i] <- NA 
  }else{
    final_ind_data$afr[i] <-
    min(cumsum(it_data[i,grep("surv",colnames(it_data))][!is.na(it_data[i,grep("surv",colnames(it_data))])])[it_data[i,grep("repro",colnames(it_data))][!is.na(it_data[i,grep("repro",colnames(it_data))])]==1])
  }
  return(final_ind_data$afr)
}

#ALR
alr <- function(final_ind_data){
 if(as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T)) == 0){
    final_ind_data$alr[i] <- NA 
  }else{
    final_ind_data$alr[i] <-
    max(cumsum(it_data[i,grep("surv",colnames(it_data))][!is.na(it_data[i,grep("surv",colnames(it_data))])])[it_data[i,grep("repro",colnames(it_data))][!is.na(it_data[i,grep("repro",colnames(it_data))])]==1])
  }
  return(final_ind_data$alr)
}

#Transition
trans <- function(final_ind_data){
  if(it_data$stage1[i]==1){
    final_ind_data$trans[i] <- NA
  } else{
    final_ind_data$trans[i] <- 
    min(cumsum(it_data[i,grep("surv",colnames(it_data))][!is.na(it_data[i,grep("surv",colnames(it_data))])])[it_data[i,grep("stage",colnames(it_data))][!is.na(it_data[i,grep("stage",colnames(it_data))])]==1])
  }
  return(final_ind_data$trans)
}
```

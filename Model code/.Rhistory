knitr::opts_chunk$set(echo = TRUE)
Sys.setlocale("LC_TIME", "C")
#install.packages("tidyverse")
library(tidyverse)
#survival
#probability of surviving
surv_p <- 0.75
#cost of surviving
surv_c <- 0.25
#age-specific cost of surviving
surv_c_age <- c(surv_c,surv_c*exp(exp(surv_c)/20*c(1:100)))
#reproduction
#probability
repro_p <- 0.5
#cost of reproduction
repro_c <- 0.25
#age-specific cost of reproduction
repro_c_age <- c(repro_c,repro_c*exp(exp(repro_c)/20*c(1:100)))
#number of descendants per reproduction
repro_n <- 1
#production
#probability
prod_p <- 0.5
#amount of resources produced
prod_n <- 1
#consumption
#amount of resources consumed
cons <- 0.25
#survival
survive <- function(it_indpop){
if(it_indpop$prod_a[i] >= surv_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(surv_p+log(it_indpop$prod_a[i]+1)/20)){
it_indpop$surv[i] <- 1
}
else{
it_indpop$surv[i] <- 0
}
return(it_indpop$surv)
}
#Pablo:
#I think a solution for the "weighting" problem is to make the survival depend on having the resources or not, so if you don't have the resources you definitely die, and if you have them you go through the random option of surviving or not.
# From Dieter: I think this goes back to the discussion in the TICEL meeting, about the function that links inputs to outputs. To me, for survival, there are two steps: first, assign an individual specific level of survival depending on the resources. So there is a function that links resources to a probability. Maybe the easiest is something similar to what you have: when resources are below a critical threshold, individuals will definitely die; if resources reach that threshold, there is a baseline survival probability; if individuals have more resources, their survival probability increases. That increase probably follows a logarithmic function, with additional resources leading to smaller increases. The second step is that we draw a random number for this individual between 0 and 1 (runif(1,min=0,max=1)) and see whether that number is smaller than the probability to survive. Here is such a suggestion. I am dividing the log benefit by 20 to bring it onto the relevant scale - so if the baseline survival is 0.75, and individual with 100 resources will now have a survival of 0.75 + log(100)/20 = 0.75 + 0.23 = 0.98. With this example, most individuals survive, so if you use this variant without changing anything else, the population will explode.
#Pablo: I changed the survival function to what you suggest and I think it clearly nails the discussion in the TICEL meeting. I have two questions: 1) why is it necessary to divide by 20 to bring it onto the relevant scale? and
# From Dieter:
# It might be useful to plot the functions to get an idea of how it influences the baseline probability. For example, should the baseline be the average or should it be the starting point? Should there be a steep incline or just a small change? Should the change be abrupt or gradual across the whole range? It also matters how you measure resources (are they measured in units of 1 or smaller units, what could the maximum be etc.) Here are four options that illustrate these differences based on what you set above that the production of resources is ~0.5 - so small steps and going up to a maximum of 10 resources (40 steps of production with baseline production (0.5) + consumption (0.25) - 40*0.25=10). I think you will probably decide the shape depending on the references you wanted to use?
#Pablo:
#If I understand correctly, dividing by 20 is to make the survival probability have values below one, right? I updated the code below then so the baseline production is 1 (0.5 is the probability of producing one resource), the resources vector would have a maximum of 75 resources (100 steps of production with baseline production (1) + consumption (0.25), 100*0.75=75), and I divide by 20, 20_neg, 10, and the dive6.
#
resources<-seq(from=0,to=75,length.out=101)
survival_probabilities_20<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20[i]<-0}else{survival_probabilities_20[i]<-surv_p+log(resources[i]+1)/20}
}
survival_probabilities_20_neg<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_20_neg[i]<-0}else{survival_probabilities_20_neg[i]<-surv_p+log(resources[i])/20}
}
survival_probabilities_10<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_10[i]<-0}else{survival_probabilities_10[i]<-surv_p+log(resources[i]+1)/10}
}
survival_probabilities_div6<-rep(0,101)
for (i in 1:length(resources)){
if(resources[i]<surv_c){survival_probabilities_div6[i]<-0}else{survival_probabilities_div6[i]<-surv_p+(log(resources[i]/2)/6) }
}
plot(survival_probabilities_20~resources,xlim=c(0,75),ylim=c(0,1.3))
abline(h=1)
points(survival_probabilities_20_neg~resources,col="red")
points(survival_probabilities_10~resources,col="blue")
points(survival_probabilities_div6~resources,col="gold",pch=2)
# From Pablo: 2) I tried to solve the issue of population explosion, by exponentiating the survival costs with age, and the same with reproductive costs, so it would be more costly to survive/reproduce when you get older. However, this made crush the population in 2-3 iterations because the costs of survival/reproduction were too high when exponentiating. Do you think it is because the values are too high or am I missing something else?
# From Dieter: Yes, exponentiating quickly leads to massive changes - e.g. if you start with survival of 0.75, the chance to survive to age 4 is 5%: 0.75*(0.75*0.75)*(0.75*0.75*0.75)*(0.75*0.75*0.75*0.75)
#Pablo: I am trying to plot the survival cost function, so that it increases with age. I think the one dividing by 20 should be smooth enough.
#survival cost only exp
#age
ages<-1:100
#surv cost at age 0
a <- 0.25
#constant exponential growth
r <- exp(surv_c)
#survival costs for ages
surv_costs <- a*exp(r*ages)
#survival cost dividing by 20
#age
ages<-1:100
#surv cost at age 0
a <- 0.25
#constant exponential growth
r_20 <- exp(surv_c)/20
#survival costs for ages
surv_costs_20 <- a*exp(r_20*ages)
#survival cost dividing by 10
#age
ages<-1:100
#surv cost at age 0
a <- 0.25
#constant exponential growth
r_10 <- exp(surv_c)/10
#survival costs for ages
surv_costs_10 <- a*exp(r_10*ages)
#survival cost dividing by div6
#age
ages<-1:100
#surv cost at age 0
a <- 0.25
#constant exponential growth
r_div6 <- exp(surv_c/2)/6
#survival costs for ages
surv_costs_div6 <- a*exp(r_div6*ages)
plot(surv_costs_20~ages,xlim=c(0,100))
points(surv_costs_10~ages,col="blue")
points(surv_costs~ages,col="red")
points(surv_costs_div6~ages,col="gold",pch=2)
####
#age
age <- function(it_indpop){
it_indpop$age[i] <- it_indpop$age[i]+it_indpop$surv[i]
return(it_indpop$age)
}
#discount survival costs
survive_c <- function(it_indpop) {
it_indpop$prod_a[i] <- it_indpop$prod_a[i]-surv_c_age[it_indpop$age[i]+1]
return(it_indpop$prod_a)
}
#production
produce <- function(it_indpop){
it_indpop$prod_o[i] <- rbinom(1,1,prod_p)
return(it_indpop$prod_o)
}
#adding resources produced
produce_a <- function(it_indpop) {
it_indpop$prod_a[i] <- it_indpop$prod_a[i]+it_indpop$prod_o[i]*prod_n
return(it_indpop$prod_a)
}
#consumption
consume <- function(it_indpop) {
it_indpop$cons[i] <- cons
it_indpop$prod_a[i] <- it_indpop$prod_a[i]-cons
return(it_indpop)
}
#Dieter:
# For both though, i wonder whether you need to plan the functions more flexibly. If I understand it correctly, the production probability can change according to the stage the individual is in. So I think that this should be part of the function definition:
# produce <- function(ind,production_probability){
#  ind$prod<-rbinom(nrow(ind),1,production_probability)
#  return(ind)
# }
# The function can than be used as:
# produce(pop,prod_p)
# Where the prod_p can be adjusted according to the stage of the individuals. Though I assume if you end up having a population where individuals are in different stages, you presumably want to make this a two-step process:
# produce <- function(ind){
#  ind$proc_b<-ifelse(ind$age<6,proc_b_infant,ifelse(ind$age<15,proc_b_juvenile,0))  # I think there is some way to set this up better
#  ind$prod<-rbinom(nrow(ind),1,ind$proc_b)
#  return(ind)
# }
#Pablo:
#I think the last option sounds like the best. However, I thought the stage-specific probabilities were set as auxiliary variables, which is why I was not considering them in the function definitions. Is this a good way to do it? Do you think is necessary to solve it for this model, where individuals don't transition to another life cycle stage, or can it be dealt in the next one where individuals have two stages?
# Dieter:
# Yes, I think for now this works. I was already thinking ahead. You could have an additional setup where there are functions that adjust the probabilities accordingly. The way you have setup it up currently though, where functions are simultaneously applied to all individuals in a vector, makes me think that the second approach I am describing will be necessary. This is because not all individuals will transition at the same time, so there will be a mix of individuals in the data frame and the function needs to consider for each individual separately which stage it is in. Or are you assuming that when individuals transition they move to a new data frame, being killed from the dataframe for stage 1 and being added to the dataframe for stage 2?
#Pablo:
#I am thinking on what you said first, not the last part of individuals moving to a new data frame. Therefore, the functions will have to consider the stage of the individual to act differently. Also, stage-specific auxiliary variables (e.g. survival costs, amount of resources produced).
#reproduction probability
reproduce <- function(it_indpop){
if(it_indpop$prod_a[i] >= repro_c_age[it_indpop$age[i]+1] & runif(1,min=0,max=1)<(repro_p+log(it_indpop$prod_a[i]+1)/20)) {
it_indpop$repro[i] <- 1
}else{
it_indpop$repro[i] <- 0
}
return(it_indpop$repro)
}
#reproductive costs
reproduce_c <- function(it_indpop) {
if(it_indpop$repro[i] == 1){
it_indpop$prod_a[i] <- it_indpop$prod_a[i]-repro_c_age[it_indpop$age[i]+1]
}else{
it_indpop$prod_a[i] <- it_indpop$prod_a[i]
}
return(it_indpop$prod_a)
}
#adding the newborn
#new_ind <- function(it_indpop){
#  it_indpop <- rbind(it_indpop,data.frame(id=(max(it_indpop$id)+1):((max(it_indpop$id)+1)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"]))))
#  return(it_indpop)
#}
#this one did not work out well so I put it directly on the code for one iteration.
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)
#run one iteration for all the population
#calculate the survival outcome
for (i in 1:nrow(it_indpop)){
#survival
it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
#age
it_indpop$age <- age(it_indpop)
#survival cost
it_indpop$prod_a <- survive_c(it_indpop)
#production outcome
it_indpop$prod_o <- produce(it_indpop)
#production amount
it_indpop$prod_a <- produce_a(it_indpop)
#consumption
it_indpop <- consume(it_indpop)
#reproduction probability
it_indpop$repro <- reproduce(it_indpop)
#reproductive cost
it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=c("1","1"))
#check the population by the end of the iteration
head(it_indpop)
#create population
it_indpop <- data.frame(id=1:1000,surv=rep(NA,length.out=1000),age=rep(0,length.out=1000),prod_o=rep(NA,length.out=1000),prod_a=rep(1,length.out=1000),cons=rep(NA,length.out=1000),repro=rep(NA,length.out=1000))
#create iteration record
it_data <- data.frame(id=1:1000)
#run 100 iterations
for (b in 1:100){
for (i in 1:nrow(it_indpop)){
#survival
it_indpop$surv <- survive(it_indpop)
}
#record survival outcome
surv_data <- it_indpop[,c("id","surv")]
#remove individuals that died
it_indpop <- it_indpop[-which(it_indpop$surv==0),]
#calculate age, survival cost, production, consumption, and reproductive outcome
for (i in 1:nrow(it_indpop)){
#age
it_indpop$age <- age(it_indpop)
#survival cost
it_indpop$prod_a <- survive_c(it_indpop)
#production outcome
it_indpop$prod_o <- produce(it_indpop)
#production amount
it_indpop$prod_a <- produce_a(it_indpop)
#consumption
it_indpop <- consume(it_indpop)
#reproduction probability
it_indpop$repro <- reproduce(it_indpop)
#reproductive cost
it_indpop$prod_a <- reproduce_c(it_indpop)
}
#record production outcome and resources available
resource_data <- it_indpop[,c("id","prod_o","prod_a")]
#record reproduction
repro_data <- it_indpop[,c("id","repro")]
#add newborns
#dataframe with newborns
new_it_indpop <- data.frame(id=(max(it_indpop$id)+1):(max(it_indpop$id)+sum(it_indpop[which(it_indpop$repro==1),"repro"])),surv=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),age=rep(0,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_o=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),prod_a=rep(1,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),cons=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])),repro=rep(NA,length.out=sum(it_indpop[which(it_indpop$repro==1),"repro"])))
#combine original population with newborns
it_indpop <- rbind(it_indpop,new_it_indpop)
#merge iteration records
it_data <- reduce(list(it_data,surv_data,repro_data,resource_data),full_join,by="id",suffix=as.character(c(b-1,b)))
}
#check the population by the end of the iterations
head(it_indpop)
#check the age distribution by the end of the iterations
hist(it_indpop$age)
?unique
?sub
grep("[a-z]", letters)
txt <- c("arm","foot","lefroo", "bafoobar")
txt
if(length(i <- grep("foo", txt)))
cat("'foo' appears at least once in\n\t", txt, "\n")
i # 2 and 4
txt[i*]
txt[i]
colnames(data_surv)
colnames(surv_data)
colnames(it_data)
x <- it_data
sub("surv"," ",colnames(x))
sub("surv."," ",colnames(x))
sub("surv\"," ",colnames(x))
)
poi
sub("\\.."," ",colnames(x))
sub("\\"," ",colnames(x))
sub("\"," ",colnames(x))
surv
sub("surv","surv",colnames(x))
sub("surv\.","surv",colnames(x))
sub("surv\..*","surv",colnames(x))
sub("\\..*","surv",colnames(x))
sub("\\..*","",colnames(x))
sub("\\..*"," ",colnames(x))
sub(".\*"," ",colnames(x))
sub(".\"," ",colnames(x))
sub("surv","\\1_",colnames(x))
sub("surv","_\\",colnames(x))
grep("surv",colnames(x))
unique(grep("surv",colnames(x)))
prefixes = grep("surv",colnames(x))
prefixes
sapply(prefixes, function(x)rowSums(data[,startsWith(colnames(x), x)]))
sapply(prefixes, function(y)rowSums(data[,startsWith(colnames(x), x)]))
sapply(prefixes, function(y)rowSums(x[,startsWith(colnames(x), x)]))
sapply(prefixes, function(y)rowSums(x[,startsWith(colnames(x), y)]))
startsWith(colnames(x),surv)
?startsWith
rowSums(x[,prefixes])
?rowSums
rowSums(x[,prefixes],na.rm = T)
View(x)
rowSums(it_data[,grep("surv",colnames(it_data))],na.rm = T=)
rowSums(it_data[,grep("surv",colnames(it_data))],na.rm = T)
rowsum(it_data[,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[1,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[2,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[3,grep("surv",colnames(it_data))],na.rm = T)
rowsum(it_data,grep("surv",colnames(it_data)),na.rm = T)
i
rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T)
x <- rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T)
x
x[2,]
dim(x)
as.numeric(x)
as.numeric(rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
rm(x)
View(it_data)
as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T))
rowSums(it_data[,grep("repro",colnames(it_data))],na.rm = T)
grep("repro",colnames(it_data))
it_data[,grep("repro",colnames(it_data))]
it_data[,grep("repro",colnames(it_data))][,2]
it_data[,grep("repro",colnames(it_data))][1,]
it_data[,grep("repro",colnames(it_data))][1,1]
it_data[,grep("repro",colnames(it_data))][1,2]
it_data[,grep("repro",colnames(it_data))][1,1:2]
it_data[,grep("repro",colnames(it_data))][1,which(it_data[,grep("repro",colnames(it_data))]==1)]
it_data[,grep("repro",colnames(it_data))][,which(it_data[,grep("repro",colnames(it_data))]==1)]
which(it_data[,grep("repro",colnames(it_data))]==1)
it_data[,grep("repro",colnames(it_data))][,which(it_data[,grep("repro",colnames(it_data))]==1)]
which(it_data[,grep("repro",colnames(it_data))]
==1
it_data[,grep("repro",colnames(it_data))]
rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[2,grep("surv",colnames(it_data))],na.rm = T)
rowSums(it_data[2,grep("repro",colnames(it_data))],na.rm = T)
rowSums(it_data[2,grep("surv",colnames(it_data))&3],na.rm = T)
rowSums(it_data[2,grep("surv",colnames(it_data))&grep("repro",colnames(it_data))],na.rm = T)
it_data[,grep("repro",colnames(it_data))]
x <- it_data[,grep("repro",colnames(it_data))]
x[2,]
which(x[,==1])
which(x[,x[,]==1])
which(colSums(x)==1)
which(x==1)
x
x[,(x[1,])==1]
((x[1,])==1)
((x[2,])==1)
(x[2,])==1
it_data[i,grep("surv",colnames(it_data))]
x[,(x[2,])==1]
y <- ((x[2,])==1)
x[,y]
as.data.frame(x[,y])
#longevity
longevity <- function(final_ind_data){
final_ind_data$age[i] <- as.numeric(rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
}
#LRO
lro <- function(final_ind_data){
final_ind_data$lro[i] <- as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T))
}
#AFR
afr <- function(final_ind_data){
final_ind_data$afr[i] <-
}
#longevity
longevity <- function(final_ind_data){
final_ind_data$age[i] <- as.numeric(rowSums(it_data[i,grep("surv",colnames(it_data))],na.rm = T))
}
#LRO
lro <- function(final_ind_data){
final_ind_data$lro[i] <- as.numeric(rowSums(it_data[i,grep("repro",colnames(it_data))],na.rm = T))
}
#AFR
#afr <- function(final_ind_data){
#  final_ind_data$afr[i] <-
#}
